# Оптимизация программы, рисующей множество [Мандельброта](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%9C%D0%B0%D0%BD%D0%B4%D0%B5%D0%BB%D1%8C%D0%B1%D1%80%D0%BE%D1%82%D0%B0)

## Введение 

Я столкнулся задачей: написать программу, рисующую множество Мандельброта, а также рааазными путями как можно больше ускорить процесс расчёта точек этого множества.

## Ход работы 

1) Для реализации графики в программе мною использовалась графическая библиотека SFML. Из разных методов, предоставляемых SFML Я выбрал способ перевода изображения на экран путём зацикленного, покадрового заполнения массива с цветом каждого пикселя отображаемого окна.

2) Написал первую версию программы. В ней координаты каждой точки множества расчитываются по-отдельности, никакие оптимизации не применялись.   

    $\qquad\qquad\qquad\qquad$ Замерение времени работы для программы в тактах процессора: 
    <img src="graphs/0.png">

$\qquad$ В тестовом запуске не включалась графика, поэтому оценка времени учитывает только затраты на расчёт и помещение точек в массив с цветами.

3) Заметил, что точки множества зависят только от своего начального положения и номера итерации, на которой они находятся, но никак не зависят друг от друга. Из этого сделал вывод, что можно упаковать точки в вектора по 4 значения и расчитывать параллельно. Конечно же это не случайный выбор. Надежды возлагались на то, что, под флагом компиляции -O2 или -O3 компилятор заменит конструкции с такими векторами на [интринсики](https://en.wikipedia.org/wiki/Intrinsic_function), являющиеся реализацией [SIMD](https://ru.wikipedia.org/wiki/SIMD)-инструкций Intel. 

    $\qquad\qquad\qquad\quad$ Аналогичное замерение времени работы для второй версии программы: 
<img src="graphs/1.png">

$\qquad$ Как видно, эта оптимизация дала прирост больше, чем в два раза.

4. На этой стадии Я ещё не решился использовать оригинальные интринсики, и, дабы упростить переход к их использованию, решил написать их аналоги на С.   

    $\qquad\qquad\qquad\qquad\qquad$ Замерение времени для третьей версии программы:
<img src="graphs/2.png">

$\qquad$ Как видно по результатам замера времени(замедление относительно базового варианта в ~3.5 раза ) этот этап нёс чисто поучительный характер. По всей видимости, ухудшение связано с тем, что компилятор не распознал в моих функциях возможности их сворачивания в конструкции с параллельными вычислениями.  

5. Перешёл, наконец, к использованию оригинальных интринсиков ( AVX, AVX2 - инструкции ). Их преимущество в том, что на уровне ассемблерного кода, каждый интринсик представляется одной ассемблерной командой (при условии указания флага -O2 или -O3 при компиляции), манипулирующей данными в XMM-регистров.

    $\qquad\qquad\qquad\qquad\qquad$ Замерение времени для четвёртой версии программы:
<img src="graphs/3.png">

$\qquad$ Как видно по графику, ускорение относительно первого варианта больше, чем в 3.5 раза. Успех! Это означает, что интринсики действительно работают.

6. С удивлением Я обнаружил, что мой процессор поддерживает технологию AVX2. Это означает, что можно производить операции с векторами по восемь чисел с плавающей запятой одинарной точности. Обрадовался этому факту, переписал программу, используя эти интринсики, и получил следующие результаты. 

    $\qquad\qquad\qquad\qquad\qquad$ Замерение времени для пятой версии программы:
<img src="graphs/4.png">

$\qquad$ Ускорение почти в 7 раз, относительно первого варианта программы !

# Заключительное сравнение 
* время работы (в тиках) посчитано как 3200 МГц / (кол-во тиков на один кадр)
    , где 3200 МГц это максимальная татктовая частота моего процессора AMD Ryzen 7 5800H
* fps без учёта графики подсчитан, как: 1 / (время работы в тиках для одного кадра)

    Этот показатель приводится чисто для удобства сравнения скорости работы разных версий программы 

|              |время работы (в тиках)  |       Отн. погр.(%)    |           fps
|--------------|:----------------------:|:----------------------:|:----------------------:|
|без оптимизации        |__(50524 +- 3) * 10 ^4__|__(6 * 10 ^-3)__|__(6.3)__|
|векторы по 4 float'а   |__(21120 +- 2) * 10 ^4__|__(8 * 10 ^-3)__|__(15.2)__|
|палёные интринсики     |__(18024 +- 6) * 10 ^5__|__(8 * 10 ^-2)__|__(1.8)__|
|оригинальные интринсики <br> по 4 float'а|__(13604 +- 2) * 10 ^4__|__(1 * 10 ^-2)__|__(23.5)__|            
|оригинальные интринсики <br> по 8 float'ов|__(7441 +- 1) * 10 ^4__|__(2 * 10 ^-2)__|__(43.0)__|
 

### Итоговое ускорение = 6.8 раз

    
$\qquad\qquad\qquad\qquad\qquad\qquad$ Общий график для наглядности:
<img src="graphs/all.png">

# Вывод 
SIMD-инструкциии могут быть полезны при опимизации параллельных операций с независящими друг от друга данными. В таком случае их можно упаковать в вектора по четыре или восемь значений (а с технологей AVX-512 ещё и по 16). Но от этого код становися тяжело воспринимать, программу становиться тяжелее дебажить, а самое главное - программа становиться зависимой от железа, то есть нет гарантии, что она с лёгкостью перенесётся на другое устройство и будет без проблем выполняться.  

# Дополнение 

$\qquad\qquad\qquad\qquad\qquad\qquad\qquad$ Само множество Мандельброта :
<img src="pics/mandelbrot1.png">

$\qquad\qquad\qquad\qquad\qquad\qquad\qquad$ Граница множества в приближении :
<img src="pics/mandelbrot4.png">

$\quad$
<img src="pics/mandelbrot3.png">

$\quad$
<img src="pics/mandelbrot2.png">


